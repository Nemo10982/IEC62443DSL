/*
 * generated by Xtext 2.32.0
 */
package org.xtext.iec62443.baseModel.validation;

import java.util.ArrayList;
import java.util.List;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.validation.Check;
import org.xtext.iec62443.baseModel.mIEC.*;
import org.xtext.iec62443.baseModel.mIEC.System;

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class MiecValidator extends AbstractMiecValidator {
	
	//
	//
	// Check that All parts of the model that have a name are uniquely named, with regards to parts of the same type.
	//
	//
	
	// Component
	@Check
	public void checkNameUnique(Component comp) {
		final String lName = comp.getName();
        EObject rootElement = EcoreUtil2.getRootContainer(comp);
        List<Component> candidates = EcoreUtil2.getAllContentsOfType(rootElement, Component.class);
        for (Component sibling: candidates) {
        	if (sibling.getName().equals(lName) && sibling != comp) {
        		error("duplicate name '" + lName +"'", MIECPackage.Literals.COMPONENT__NAME);
        	}
        }
	}
	// Zone
	@Check
	public void checkNameUnique(Zone z) {
		final String lName = z.getName();
        EObject rootElement = EcoreUtil2.getRootContainer(z);
        List<Zone> candidates = EcoreUtil2.getAllContentsOfType(rootElement, Zone.class);
        for (Zone sibling: candidates) {
        	if (sibling.getName().equals(lName) && sibling != z) {
        		error("duplicate name '" + lName +"'", MIECPackage.Literals.ZONE__NAME);
        	}
        }
	}
	// CounterMeasure
	@Check
	public void checkNameUnique(CounterMeasure c) {
		final String lName = c.getName();
        EObject rootElement = EcoreUtil2.getRootContainer(c);
        List<CounterMeasure> candidates = EcoreUtil2.getAllContentsOfType(rootElement, CounterMeasure.class);
        for (CounterMeasure sibling: candidates) {
        	if (sibling.getName().equals(lName) && sibling != c) {
        		error("duplicate name '" + lName +"'", MIECPackage.Literals.COUNTER_MEASURE__NAME);
        	}
        }
	}
	// Channels
	@Check
	public void checkNameUnique(Channel c) {
		final String lName = c.getName();
        EObject rootElement = EcoreUtil2.getRootContainer(c);
        List<Channel> candidates = EcoreUtil2.getAllContentsOfType(rootElement, Channel.class);
        for (Channel sibling: candidates) {
        	if (sibling.getName().equals(lName) && sibling != c) {
        		error("duplicate name '" + lName +"'", MIECPackage.Literals.CHANNEL__NAME);
        	}
        }
	}
	
	// Properties in a given component
	@Check
	public void checkNameUniqueProperties(Property p) {
		final String lName = p.getName();
        EObject parentElement = p.eContainer();
        List<Property> candidates = ((Component) parentElement).getProperties();
        for (Property sibling: candidates) {
        	if (sibling.getName().equals(lName) && sibling != p) {
        		error("duplicate name '" + lName +"'", MIECPackage.Literals.PROPERTY__NAME);
        	}
        }
	}
	
	
	//
	//
	// Check that the same element is never mentioned twice in a list
	//
	//
	
	// connected zones
		@Check
		public void checkZonesConnectedUnique(Conduit c) {
			final String lName = c.getName();
	        List<String> alreadySeen = new ArrayList<>();
	        for (Zone contained: c.getConnects()) {
	        	if (alreadySeen.contains(contained.getName())) {
	        		error("A zone is connected multiple times by conduit '" + lName +"' : " + contained.getName(), MIECPackage.Literals.CONDUIT__CONNECTS);
	        	}
	        	else {
	        		alreadySeen.add(contained.getName());
	        	}
	        }
		}
		
	// connected components
		@Check
		public void checkZonesConnectedUnique(Channel c) {
			final String lName = c.getName();
	        List<String> alreadySeen = new ArrayList<>();
	        for (Component contained: c.getConnects()) {
	        	if (alreadySeen.contains(contained.getName())) {
	        		error("A component is connected multiple times by channel '" + lName +"' : " + contained.getName(), MIECPackage.Literals.CHANNEL__CONNECTS);
	        	}
	        	else {
	        		alreadySeen.add(contained.getName());
	        	}
	        }
		}
		
		
		
		// Check that security target level are never set to NR (not relevant)
		

		@Check
		public void checkSecurityLevelNR(Zone z) {
			final String lName = z.getName();
			// Check target

        	for (int i = 0; i < 7; i++) {
        		if (z.getTarget().getSecurityLevel(i).getValue() == SecurityLevel.NR_VALUE) {
        			error("The zone '" + lName +"' has a target security level set to NR (not relevant)" , MIECPackage.Literals.ZONE__TARGET);
        			break;
        		}
        	}
			
		}
	
	
		
		//
		//
		// Check that the target security levels in a subzone are equal or higher than their parent's counterparts.
		//
		//
		
		@Check
		public void checkSecurityLevelHierarchy(Zone z) {
			final String lName = z.getName();
			Zone parent = z.getIsSubZoneOf();
	        if (parent != null) {
	        	
	        	// Check target
	        	for (int i = 0; i < 7; i++) {
	        		if (z.getTarget().getSecurityLevel(i).getValue() < parent.getTarget().getSecurityLevel(i).getValue()) {
	        			error("The zone '" + lName +"' has lower target SL than its parent: " + parent.getName(), MIECPackage.Literals.ZONE__TARGET);
	        			break;
	        		}
	        	}
	        }
		}
	
	
//		//
//		//
//		// Check that no zone is a subzone (recursively or not) of itself
//		// No longer a possibility
//		//
//		//
//		@Check
//		public void checkNoSubZoneCycle(Zone z) {
//			final String lName = z.getName();
//			Zone parent = z.getIsSubZoneOf();
//
//	        List<String> alreadySeen = new ArrayList<>(); // used for cases where there is a cycle, but not related to the starting zone
//			while (parent != null && !alreadySeen.contains(parent.getName())) {
//				if (parent == z) {
//					error("The zone '" + lName +"' is a subZone of itself", MIECPackage.Literals.ZONE__IS_SUB_ZONE_OF);
//				}
//				else {
//					alreadySeen.add(parent.getName());
//					parent = parent.getIsSubZoneOf();
//				}
//			}
//		}
		
		
		//
		//
		// Check that a conduit does not connect itself
		//
		//
		@Check
		public void checkConduitNotConnectItself(Conduit c) {
			final String lName = c.getName();
	        if (c.getConnects().contains(c)) {
	        	error("The conduit '" + lName +"' tries to connects to itself", MIECPackage.Literals.CONDUIT__CONNECTS);
	        }
		}
		
	
		//
		//
		// Check that channels connect components that are parts of the zones its parent conduit connects (or part of the parent conduit).
		//
		//
		
		@Check
		public void checkChannelConnectsAppropriate(Channel c) {
			final String lName = c.getName();
			Conduit parent = (Conduit) c.eContainer();
			List<Zone> linkedZones = new ArrayList<>();
			// Add all zones linked by the conduit
			linkedZones.addAll(parent.getConnects());
			// Add the conduit
			linkedZones.add(parent);
			for (Component comp: c.getConnects()) {
				Zone compParent = (Zone) comp.eContainer();
				if (!linkedZones.contains(compParent)){
					error("The channel '" + lName +"' connects a component that is not in the zone its parent connects : " + comp.getName(), MIECPackage.Literals.CHANNEL__CONNECTS);
				}
			}
	        
		}
		
		
		// Check that applications are appropriately run on a device in their zone (and whether or not it is running).
		
		@Check
		public void checkApplicationRunLocally(Application a) {
			final String lName = a.getName();
			Zone parent = (Zone) a.eContainer();
			// If the application is not currently executed, no checks are made
			if (a.getProperty("attacked") != null || (a.getProperty("state") != null && a.getProperty("state").getValue().getStringValue() == "2")) {
				return;
			}
			if (a.getExecutedOn() == null) {
				warning("The application '" + lName +"' is not executed", MIECPackage.Literals.APPLICATION__EXECUTED_ON);
			}
			if (!EcoreUtil2.equals(parent, a.getExecutedOn().getZone())) {
				error("The application '" + lName +"' run on device '" + a.getExecutedOn().getName() +"' which is not in the same zone", MIECPackage.Literals.APPLICATION__EXECUTED_ON);
			}
	        
		}

		// Check that applications scores are properly typed (integer, cast at the end).
		
		@Check
		public void checkApplicationScoreProperlyTyped(Application a) {
			final String lName = a.getName();
			if (a.getScoreExpr() == null || a.getExecutedOn() == null) {
				return;
			}
			if (!Expression.properlyTyped(a.getScoreExpr(), a, a.getExecutedOn(), Value.INTEGER)) {
				warning("The application '" + lName +"' running on device '" + a.getExecutedOn().getName() +"' may not have a properly typed score", MIECPackage.Literals.APPLICATION__SCORE_EXPR);
			}
	        
		}
		
//		//
//		//
//		// Not really a check, not sure if i will keep it
//		// Actually sets the subZone as a symmetric relation
//		//
//		//
//
//		
//		@Check
//		public void symetricSubRelation(Zone z) {
//			ClassicalZone parent = z.getIsSubZoneOf();
//			if (parent != null) {
//				parent.getSubZones().add(z);
//			}
//	        
//		}
		
		
		
		// Countermeasures costs are always positive or zero

		@Check
		public void checkCostPositive(CounterMeasure c) {

			final String lName = c.getName();
			
			if (c.getCost() != null && c.getCost().getValue() < 0) {
				error("Countermeasure '" + lName +"' has a negative cost", MIECPackage.Literals.COUNTER_MEASURE__COST);
			}
		}
		
		
		//
		//
		// Check that the target security level is achievable
		//
		//
		
		@Check
		public void checkTarget(Zone z) {
			
			// If there are no components: There's no need to check anything
			if (z.getComponents().size() == 0) return;
			
			final String lName = z.getName();
			Integer[] givenTarget = {4,4,4,4,4,4,4};
			for (int i = 0; i < 7; i++) {
				givenTarget[i] = z.getTarget().getSecurityLevel(i).getValue();
			}
			Integer[] computedAchievedComponent = {4,4,4,4,4,4,4};
			Integer[] computedAchievedCountermeasure = {0,0,0,0,0,0,0};
			Integer[] computedAchieved = {4,4,4,4,4,4,4};

			
			// Max of the capability of the countermeasures
			for (CounterMeasure c: z.getCountermeasures()) {
				
				// Inactive measure do not count
				if (!c.isInactive()) {
					for (int i = 0; i < 7; i++) {
						
						// Ignore NR security levels
						if (c.getCapability().getSecurityLevel(i).getValue() == SecurityLevel.NR_VALUE) continue;
						
						computedAchievedCountermeasure[i] = Math.max(computedAchievedCountermeasure[i], c.getCapability().getSecurityLevel(i).getValue());
					}
				}
			}
			
			
			
			// Min of the capability of components
			for (Component c: z.getComponents()) {
				// If the target is a stopped application, ignore it
				if (c.getType() == Component.APPLICATION && c.getProperty("state") != null && c.getProperty("state").getValue().getStringValue().equals("2")) {
					continue;
				}
				for (int i = 0; i < 7; i++) {
					int componentSLevel_i = c.getCapability().getSecurityLevel(i).getValue();
					
					// Ignore NR security levels
					if (componentSLevel_i == SecurityLevel.NR_VALUE) continue;
					
					computedAchievedComponent[i] = Math.min(computedAchievedComponent[i], componentSLevel_i);
					// A component has a slevel that's too low for the given achieved level:
					if (componentSLevel_i < givenTarget[i] && givenTarget[i] > computedAchievedCountermeasure[i]) {
						error("The given target level of requirement " + getFR(i) + " of zone '" + lName +"' is not compatible with component : " + c.getName(), MIECPackage.Literals.ZONE__COMPONENTS);
					}
				}
			}
			
			boolean err = false;
			for (int i = 0; i < 7; i++) {
				computedAchieved[i] = Math.max(computedAchievedComponent[i], computedAchievedCountermeasure[i]);
				if (computedAchieved[i] < givenTarget[i]) {
					err = true;
				}
			}
			if (err) {
				error("The given target level of requirement of zone '" + lName +"' can't be achieved ", MIECPackage.Literals.ZONE__TARGET);
			}
			
			// Check
		}
		
		//
		//
		// Check that the achieved security level is correct (max(min(capability of components), max(capability of countermeasures))
		// Does not output an error, but a warning
		//
		//
	
		
		// Useless now, this is a derived value
		
		
//		@Check
//		public void checkAchieved(Zone z) {
//			
//			// If there are no components: There's no need to check anything
//			if (z.getComponents().size() == 0) return;
//			
//			final String lName = z.getName();
//			Integer[] givenAchieved = {4,4,4,4,4,4,4};
//			for (int i = 0; i < 7; i++) {
//				givenAchieved[i] = z.getAchieved().getSecurityLevel(i).getValue();
//			}
//			Integer[] computedAchievedComponent = {4,4,4,4,4,4,4};
//			Integer[] computedAchievedCountermeasure = {0,0,0,0,0,0,0};
//			Integer[] computedAchieved = {4,4,4,4,4,4,4};
//
//			
//			// Max of the capability of the countermeasures
//			for (CounterMeasure c: z.getCountermeasures()) {
//				for (int i = 0; i < 7; i++) {
//					computedAchievedCountermeasure[i] = Math.max(computedAchievedCountermeasure[i], c.getCapability().getSecurityLevel(i).getValue());
//				}
//			}
//			
//			
//			
//			// Min of the capability of components
//			for (Component c: z.getComponents()) {
//				for (int i = 0; i < 7; i++) {
//					int componentSLevel_i = c.getCapability().getSecurityLevel(i).getValue();
//					computedAchievedComponent[i] = Math.min(computedAchievedComponent[i], componentSLevel_i);
//					// A component has a slevel that's too low for the given achieved level:
//					if (componentSLevel_i < givenAchieved[i] && givenAchieved[i] > computedAchievedCountermeasure[i]) {
//						warning("The given achieved level of requirement " + getFR(i) + " for zone '" + lName +"' is not compatible with component : " + c.getName(), MIECPackage.Literals.ZONE__ACHIEVED);
//					}
//				}
//			}
//			
//			boolean err = false;
//			for (int i = 0; i < 7; i++) {
//				computedAchieved[i] = Math.max(computedAchievedComponent[i], computedAchievedCountermeasure[i]);
//				if (computedAchieved[i] != givenAchieved[i]) {
//					err = true;
//				}
//			}
//			if (err) {
//				warning("The given achieved level of requirement of zone '" + lName +"' is should be : " + getSL(computedAchieved), MIECPackage.Literals.ZONE__ACHIEVED);
//			}
//			
//			// Check
//		}
		
		// Utility functions for the previous check
		private String getFR(int i) {
			switch(i) {
				case 0:
					return "accessControl";
				case 1:
					return "useControl";
				case 2:
					return "systemIntegrity";
				case 3:
					return "dataConfidentiality";
				case 4:
					return "restrictedDataFlow";
				case 5:
					return "timelyResponse";
				case 6:
					return "resourceAvailability";
				}
				return null;
		}
		
//		private String getSL(Integer[] sl) {
//			String res = "[SL" + sl[0];
//			for (int i = 1; i < 7; i++) {
//				res += ", SL" + sl[i];
//			}
//			res += "]";
//			return res;
//		}
	
//	
//		//
//		//
//		// Check that, for every application, the device it is executing on is correctly constrained 
//		//
//		//
//		@Check
//		public void checkConstraints(Application a) {
//			final String lName = a.getName();
//			
//			Device d = a.getExecutedOn();
//			for(Constraint cs: a.getConstraints()) {
//				Property interestingP = null;
//				boolean found = false;
//				for (Property p: d.getProperties()) {
//					if (p.getName().equals(cs.getPropertyName())) {
//						found = true;
//						interestingP = p;
//						break;
//					}
//				}
//				if (!found) {
//					error("The property '" + cs.getPropertyName()  +"' necessary for application '" + lName +"' is not present in device : '" + d.getName() + d.getProperties() +"'", MIECPackage.Literals.APPLICATION__EXECUTED_ON);
//					continue;
//				}
//				// If the constraint is an operation
//				if (cs.getTypeConstraint() == Constraint.OPERATION) {
//					OperationConstraint csOp = (OperationConstraint) cs;
//					// Differentiate constraints based on direct values, and constraints based on referenced values
//					Value val = null;
//					if (csOp.getValue().isReference()) {
//						val = ((Reference) csOp.getValue()).getReference().getValue();
//					}
//					else {
//						val = ((Value) csOp.getValue());
//					}
//						
//					int type = val.getType();
//					int type2  = interestingP.getValue().getType();
//					if (type != type2) {
//						error("The property '" + cs.getPropertyName()  +"' necessary for application '" + lName +"' does not have the correct type in device : '" + d.getName() +"'", MIECPackage.Literals.APPLICATION__EXECUTED_ON);
//						continue;
//					}
//					Operation op = csOp.getOperation();
//					boolean res = Value.compare(interestingP.getValue(), op, val);
//					if (!res) {
//						error("The constraint (" + csOp.getPropertyName() + " " + op.getLiteral() + " " + valueToString(csOp.getValue())   +") necessary for application '" + lName +"' is not verified in device : '" + d.getName() +"'", MIECPackage.Literals.APPLICATION__EXECUTED_ON);
//					}
//				}
//			}
//			
//			
//			
//		}
	
	
		//
		//
		// Check that, for every application constraints, the device it is executing on is correctly constrained 
		//
		//
		@Check
		public void checkConstraints(Constraint  cs) {
			final String lName = ((Application)cs.eContainer()).getName();
			
			Device d = ((Application)cs.eContainer()).getExecutedOn();
			// If the application is not executed, stop checking
			if (d == null) {
				return;
			}
			Property interestingP = null;
			boolean found = false;
			for (Property p: d.getProperties()) {
				if (p.getName().equals(cs.getPropertyName())) {
					found = true;
					interestingP = p;
					break;
				}
			}
			if (!found) {
				if (cs.isOptional()) {

					warning("The property '" + cs.getPropertyName()  +"' necessary for application '" + lName +"' is not present in device : '" + d.getName() + d.getProperties() +"'", MIECPackage.Literals.CONSTRAINT__PROPERTY_NAME);
				}
				else {
					error("The property '" + cs.getPropertyName()  +"' necessary for application '" + lName +"' is not present in device : '" + d.getName() + d.getProperties() +"'", MIECPackage.Literals.CONSTRAINT__PROPERTY_NAME);
					
				}
				return;
			}
			// If the constraint is an operation
			if (cs.getTypeConstraint() == Constraint.OPERATION) {
				OperationConstraint csOp = (OperationConstraint) cs;
				// Differentiate constraints based on direct values, and constraints based on self / device referenced values
				Value val = null;
				
				if (csOp.getValue().getRefType()==ValueOrReference.SELFREF) {
					val = ((Reference) csOp.getValue()).getValue();
					

					if (val == null) {
						if (cs.isOptional()) {
							warning("The property '" + ((Reference) csOp.getValue()).getReference()  +"' necessary for application '" + lName +"' is not present in the application", MIECPackage.Literals.CONSTRAINT__PROPERTY_NAME);
							
						}
						else {
							error("The property '" + ((Reference) csOp.getValue()).getReference()  +"' necessary for application '" + lName +"' is not present in the application", MIECPackage.Literals.CONSTRAINT__PROPERTY_NAME);
							
						}
						return;
					}
					
					int type = val.getType();
					int type2  = interestingP.getValue().getType();
					if (type != type2) {
						if (cs.isOptional()) {
							warning("The property '" + cs.getPropertyName()  +"' necessary for application '" + lName +"' does not have the correct type in the application", MIECPackage.Literals.CONSTRAINT__PROPERTY_NAME);
							
						}
						else {
							error("The property '" + cs.getPropertyName()  +"' necessary for application '" + lName +"' does not have the correct type in the application" + d.getName() +"'", MIECPackage.Literals.CONSTRAINT__PROPERTY_NAME);
							
						}
						return;
					}
					Operation op = csOp.getOperation();
					boolean res = Value.compare(interestingP.getValue(), op, val);
					if (!res) {
						if (cs.isOptional()) {
							warning("The constraint (" + csOp.getPropertyName() + " " + op.getLiteral() + " " + valueToString(csOp.getValue())   +") necessary for application '" + lName +"' is not verified in the application", MIECPackage.Literals.CONSTRAINT__PROPERTY_NAME);
						}
						else {
							error("The constraint (" + csOp.getPropertyName() + " " + op.getLiteral() + " " + valueToString(csOp.getValue())   +") necessary for application '" + lName +"' is not verified in the application", MIECPackage.Literals.CONSTRAINT__PROPERTY_NAME);
							
						}
					}
				}
				else {
						if (csOp.getValue().getRefType()==ValueOrReference.REF) {
						val = ((Reference) csOp.getValue()).getValue();
					}
					else if (csOp.getValue().getRefType()==ValueOrReference.VALUE) {
						val = ((Value) csOp.getValue());
					}

						
					if (val == null) {
						if (cs.isOptional()) {
							warning("The property '" + ((Reference) csOp.getValue()).getReference()  +"' necessary for application '" + lName +"' is not present in device : '" + d.getName() +"'", MIECPackage.Literals.CONSTRAINT__PROPERTY_NAME);
							
						}
						else {
							error("The property '" + ((Reference) csOp.getValue()).getReference() +"' necessary for application '" + lName +"' is not present in device : '" + d.getName() +"'", MIECPackage.Literals.CONSTRAINT__PROPERTY_NAME);
							
						}
						return;
					}
						
					int type = val.getType();
					int type2  = interestingP.getValue().getType();
					if (type != type2) {
						if (cs.isOptional()) {
							warning("The property '" + cs.getPropertyName()  +"' necessary for application '" + lName +"' does not have the correct type in device : '" + d.getName() +"'", MIECPackage.Literals.CONSTRAINT__PROPERTY_NAME);
							
						}
						else {
							error("The property '" + cs.getPropertyName()  +"' necessary for application '" + lName +"' does not have the correct type in device : '" + d.getName() +"'", MIECPackage.Literals.CONSTRAINT__PROPERTY_NAME);
							
						}
						return;
					}
					Operation op = csOp.getOperation();
					boolean res = Value.compare(interestingP.getValue(), op, val);
					if (!res) {
						if (cs.isOptional()) {
							warning("The constraint (" + csOp.getPropertyName() + " " + op.getLiteral() + " " + valueToString(csOp.getValue())   +") necessary for application '" + lName +"' is not verified in device : '" + d.getName() +"'", MIECPackage.Literals.CONSTRAINT__PROPERTY_NAME);
						}
						else {
							error("The constraint (" + csOp.getPropertyName() + " " + op.getLiteral() + " " + valueToString(csOp.getValue())   +") necessary for application '" + lName +"' is not verified in device : '" + d.getName() +"'", MIECPackage.Literals.CONSTRAINT__PROPERTY_NAME);
							
						}
					}
				}
			}
		}
		
		//
		// Utility function for precedent check
		//
		
		private String valueToString(ValueOrReference vr) {
			if (vr.getRefType() > 0){
				return ((Reference) vr).getReference();
			}
			else {
				Value v = ((Value) vr);
				switch(v.getType()) {
				case Value.BOOLEAN:
					return Boolean.toString(((BooleanValue) v).isValue());
				case Value.INTEGER:
					return Integer.toString(((IntegerValue) v).getValue());
				case Value.FLOAT:
					return Float.toString(((FloatValue) v).getValue());
				case Value.STRING:
					return ((StringValue) v).getValue();
				}
			}
			return "";
		}
		
		
		//
		//
		// Check that applications can access the components they communicate with
		//
		//

//		@Check
//		public void checkAccess(Application a) {
//			
//			final String lName = a.getName();
//			// Form the list of potential candidates
//			List<Component> candidates = new ArrayList<>();
//			// The device the application run on is one
//			candidates.add(a.getExecutedOn());
//			
//			// Then the components connected through a conduit, either to the application or to the device it runs on
//	        EObject rootElement = EcoreUtil2.getRootContainer(a);
//	        List<Channel> channels = EcoreUtil2.getAllContentsOfType(rootElement, Channel.class);
//	        for (Channel c : channels) {
//	        	if (c.getConnects().contains(a) || c.getConnects().contains(a.getExecutedOn()) ) {
//	        		for (Component c2 : c.getConnects()) { 
//						if (!candidates.contains(c2)) {
//							candidates.add(c2);
//		        			// Then check if it is a Device, add the applications that run on it
//		        			if (c2.getType() == Component.DEVICE) {
//		        				for (Application a2: ((Device)c2).getRunning()) {
//		        					if (!candidates.contains(a2)) candidates.add(a2);
//		        				}
//		        			}
//		        			// If it is a system, add the devices it contains, then the applications that run on it.
//		        			if (c2.getType() == Component.SYSTEM) {
//		        				for (Device d: ((System)c2).getDevices()) {
//		        					if (!candidates.contains(d)) {
//		    							candidates.add(d);
//				        				for (Application a2: d.getRunning()) {
//				        					if (!candidates.contains(a2)) candidates.add(a2);
//				        				}
//		        					}
//		        				}
//		        			}
//		        			
//						}
//	        		}
//	        	}
//	        }
//			
//			for(Component c: a.getCommunicatesWith()) {
//				if (!candidates.contains(c)) {
//					error("Application '" + lName +"' can't access the component : '" + c.getName() +"'", MIECPackage.Literals.APPLICATION__COMMUNICATES_WITH);
//				}
//				
//			}
//			
//			
//			
//		}
	
		//
		//
		// Check that applications can access the components they communicate with
		// Contrary to the commented one above, only takes into account conduits, and not channels
		//
		//

		@Check
		public void checkAccess(Application a) {
			
			final String lName = a.getName();
			// Form the list of potential candidates
			List<Component> candidates = new ArrayList<>();
			// The device the application run on is one, as is the rest of the system it could be part of
			candidates.add(a.getExecutedOn());
			
			if (a.getExecutedOn() != null && a.getExecutedOn().eContainer().eClass().isInstance(System.class)) {
				for (Device d : (((System)a.getExecutedOn().eContainer()).getDevices())) {
					if (!candidates.contains(d)) candidates.add(d);
				}
			}
			
			// Then the components connected through a conduit, either to the application or to the device it runs on
	        EObject rootElement = EcoreUtil2.getRootContainer(a);
	        List<Conduit> conduits = EcoreUtil2.getAllContentsOfType(rootElement, Conduit.class);
	        for (Conduit c : conduits) {
	        	if (c.getConnects().contains(a.getZone())) {
	        		for (Zone z : c.getConnects()) {
		        		for (Component c2 : z.getComponents()) { 
							if (!candidates.contains(c2)) {
								candidates.add(c2);
			        			// Then check if it is a Device, add the applications that run on it
			        			if (c2.getType() == Component.DEVICE) {
			        				for (Application a2: ((Device)c2).getRunning()) {
			        					if (!candidates.contains(a2)) candidates.add(a2);
			        				}
			        			}
			        			// If it is a system, add the devices it contains, then the applications that run on it.
			        			if (c2.getType() == Component.SYSTEM) {
			        				for (Device d: ((System)c2).getDevices()) {
			        					if (!candidates.contains(d)) {
			    							candidates.add(d);
					        				for (Application a2: d.getRunning()) {
					        					if (!candidates.contains(a2)) candidates.add(a2);
					        				}
			        					}
			        				}
			        			}
			        			
							}
		        		}
		        		for (Component c2 : c.getComponents()) { 
							if (!candidates.contains(c2)) {
								candidates.add(c2);
			        			// Then check if it is a Device, add the applications that run on it
			        			if (c2.getType() == Component.DEVICE) {
			        				for (Application a2: ((Device)c2).getRunning()) {
			        					if (!candidates.contains(a2)) candidates.add(a2);
			        				}
			        			}
			        			// If it is a system, add the devices it contains, then the applications that run on it.
			        			if (c2.getType() == Component.SYSTEM) {
			        				for (Device d: ((System)c2).getDevices()) {
			        					if (!candidates.contains(d)) {
			    							candidates.add(d);
					        				for (Application a2: d.getRunning()) {
					        					if (!candidates.contains(a2)) candidates.add(a2);
					        				}
			        					}
			        				}
			        			}
			        			
							}
		        		}
	        	}
	        }
			
			
			
		}
	        // debug code
//        java.lang.System.out.println("****");
//		java.lang.System.out.println(a.getName());
//        java.lang.System.out.println("**");
//		java.lang.System.out.println(candidates);
//        java.lang.System.out.println("**");
//		java.lang.System.out.println(a.getCommunicatesWith());
//        java.lang.System.out.println("****");
		for(Component c: a.getCommunicatesWith()) {
			if (!candidates.contains(c)) {
				error("Application '" + lName +"' can't access the component : '" + c.getName() +"'", MIECPackage.Literals.APPLICATION__COMMUNICATES_WITH);
			}
			
		}
	}
}
