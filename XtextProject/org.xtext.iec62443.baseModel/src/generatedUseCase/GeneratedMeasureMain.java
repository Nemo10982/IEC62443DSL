/*
 * generated by Xtext 2.32.0
 */
package generatedUseCase;

import com.google.inject.Inject;

import javax.swing.*;
import java.io.File;
import java.io.FileOutputStream;

import com.google.inject.Injector;
import com.google.inject.Provider;
import com.google.ortools.Loader;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.List;
import java.util.Random;
import java.util.Scanner;

import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.emf.ecore.resource.impl.ResourceImpl;
import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.generator.GeneratorContext;
import org.eclipse.xtext.generator.GeneratorDelegate;
import org.eclipse.xtext.generator.JavaIoFileSystemAccess;
import org.eclipse.xtext.resource.XtextResource;
import org.eclipse.xtext.util.CancelIndicator;
import org.eclipse.xtext.validation.CheckMode;
import org.eclipse.xtext.validation.IResourceValidator;
import org.eclipse.xtext.validation.Issue;
import org.xtext.iec62443.baseModel.mIEC.Component;
import org.xtext.iec62443.baseModel.mIEC.Device;
import org.xtext.iec62443.baseModel.mIEC.Model;
import org.xtext.iec62443.baseModel.MiecStandaloneSetup;
import org.xtext.iec62443.baseModel.transformation.Reconfiguration;
import org.xtext.iec62443.baseModel.transformation.ReconfigurationConstraintP;
import org.xtext.iec62443.baseModel.transformation.SecurityRequirements;
import org.xtext.iec62443.baseModel.userInterface.ComponentChooser;
import org.xtext.iec62443.baseModel.userInterface.FunctionalityChooser;

public class GeneratedMeasureMain {

	public static void main(String[] args) {
		
		


        // Check if the user selected a file

		Injector injector = new MiecStandaloneSetup().createInjectorAndDoEMFRegistration();
		GeneratedMeasureMain main = injector.getInstance(GeneratedMeasureMain.class);
		try {
			main.runGenerator();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			System.err.println("An error happened: " + e);
		}

//		if (args.length == 0) {
//			System.err.println("Aborting: no path to EMF resource provided!");
//			return;
//		}
	}

	@Inject
	private Provider<ResourceSet> resourceSetProvider;

	@Inject
	private IResourceValidator validator;

	@Inject
	private GeneratorDelegate generator;

	@Inject 
	private JavaIoFileSystemAccess fileAccess;

	protected void runGenerator() throws IOException {

		// Load the resource set
		ResourceSet set = resourceSetProvider.get();
		long timeStart;
		long currentMeasure;
		File dir = new File("./generatedExamples");
		
		File output = new File("ControlDelayGenerated_"+ new SimpleDateFormat("yyyyMMdd_HHmmss").format(Calendar.getInstance().getTime()) +".tsv");
		FileWriter outputW;
		outputW = new FileWriter(output);
		outputW.write("zoneAmount\tcomputationTime"+ "\n");
		Random randGen = new Random(); 
		File[] allFiles = dir.listFiles();
		Loader.loadNativeLibraries();
		if (allFiles != null) {
			for (File file : allFiles) {
				Resource resource = set.getResource(URI.createFileURI(file.getPath()), true);
				System.out.println("Loaded " + file.getName());
	
				// Validate the resource
				List<Issue> list = validator.validate(resource, CheckMode.ALL, CancelIndicator.NullImpl);
				if (!list.isEmpty()) {
					for (Issue issue : list) {
						System.err.println(issue);
					}
					return;
				}
	
				Model m = (Model) resource.getAllContents().next();
				// Get the number of zones from the file name
			    String st = file.getName();
			    String[] stList = st.split("_");
				int nbZone = Integer.parseInt(stList[2]);
				int toRem = randGen.nextInt(nbZone*2); // Choose a random device
				Device toRemD = m.getDevice("d_" + toRem);
				
				timeStart = System.currentTimeMillis();
	
	            Model m2 = ReconfigurationConstraintP.reconfigureWithout(toRemD, m, false);
				
				currentMeasure = System.currentTimeMillis()-timeStart;
				outputW.write(nbZone + "\t" + currentMeasure+ "\n");
				outputW.flush();
				
		    }
		  }
		  outputW.close();
		
		
		
		
		
		
	}
}
