/*
 * generated by Xtext 2.32.0
 */
package fischertechnikUseCase;

import com.google.inject.Inject;

import javax.swing.*;
import java.io.File;
import java.io.FileOutputStream;

import com.google.inject.Injector;
import com.google.inject.Provider;
import com.google.ortools.Loader;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.List;
import java.util.Random;
import java.util.Scanner;

import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.emf.ecore.resource.impl.ResourceImpl;
import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.generator.GeneratorContext;
import org.eclipse.xtext.generator.GeneratorDelegate;
import org.eclipse.xtext.generator.JavaIoFileSystemAccess;
import org.eclipse.xtext.resource.XtextResource;
import org.eclipse.xtext.util.CancelIndicator;
import org.eclipse.xtext.validation.CheckMode;
import org.eclipse.xtext.validation.IResourceValidator;
import org.eclipse.xtext.validation.Issue;
import org.xtext.iec62443.baseModel.mIEC.Component;
import org.xtext.iec62443.baseModel.mIEC.Device;
import org.xtext.iec62443.baseModel.mIEC.Model;
import org.xtext.iec62443.baseModel.MiecStandaloneSetup;
import org.xtext.iec62443.baseModel.transformation.Reconfiguration;
import org.xtext.iec62443.baseModel.transformation.ReconfigurationConstraintP;
import org.xtext.iec62443.baseModel.transformation.SecurityRequirements;
import org.xtext.iec62443.baseModel.userInterface.ComponentChooser;
import org.xtext.iec62443.baseModel.userInterface.FunctionalityChooser;

import de.re.easymodbus.exceptions.ModbusException;
import de.re.easymodbus.modbusclient.ModbusClient;
public class UseCaseMain {


	
	final static String PLC1Addr = "192.168.1.1";

	final static String PLC2Addr = "192.168.1.2";

	final static String m340Addr = "192.168.1.3";

	final static String PLC3Addr = "192.168.1.4";

	final static String PLC4Addr = "192.168.1.5";

	
	public static void main(String[] args) {
		
		

        File selectedFile = new File("./examples/fischerModel.miec");
		Injector injector = new MiecStandaloneSetup().createInjectorAndDoEMFRegistration();
		UseCaseMain main = injector.getInstance(UseCaseMain.class);
		main.runGenerator(selectedFile.getPath());
		
	}

	@Inject
	private Provider<ResourceSet> resourceSetProvider;

	@Inject
	private IResourceValidator validator;

	@Inject
	private GeneratorDelegate generator;

	@Inject 
	private JavaIoFileSystemAccess fileAccess;

	protected void runGenerator(String string) {

		ModbusClient PLC1Client,PLC2Client,PLC3Client,PLC4Client,M340Client;
		try {
			
			// Connects to all PLCs, and keep the separate connections opened
			
			PLC1Client = new ModbusClient(PLC1Addr, 502);
			PLC2Client = new ModbusClient(PLC2Addr, 502);
			PLC3Client = new ModbusClient(PLC3Addr, 502);
			PLC4Client = new ModbusClient(PLC4Addr, 502);
			M340Client = new ModbusClient(m340Addr, 502);
			
			PLC1Client.Connect();
			PLC2Client.Connect();
			PLC3Client.Connect();
			PLC4Client.Connect();
			M340Client.Connect();
			
		} catch (Exception e) {
			System.out.println("Error while opening the modbus connections");
			return;
		}
		
		// Load the resource
		ResourceSet set = resourceSetProvider.get();
		Resource resource = set.getResource(URI.createFileURI(string), true);

		// Validate the resource
		List<Issue> list = validator.validate(resource, CheckMode.ALL, CancelIndicator.NullImpl);
		if (!list.isEmpty()) {
			for (Issue issue : list) {
				System.err.println(issue);
			}
			return;
		}
		
		
		// Load the solver

		Loader.loadNativeLibraries();

		Model m = (Model) resource.getAllContents().next();
		
		
		ControlProgramMigration cpm = new ControlProgramMigration(m, PLC1Client, PLC2Client, PLC3Client, PLC4Client, M340Client);
		try {
			cpm.resetAllPLC();
		} catch (ModbusException | IOException | InterruptedException e) {
			e.printStackTrace();
			System.err.println("Issue arose while trying to communicate with PLCs at init time");
		}
		
		// Remove a random PLC ten times
	    int NBMEASURE = 2;
		long TimeTable[][] = new long[NBMEASURE+1][2];
		String plcNameArray[] = {"PLCA1","PLCB1","PLCC1","PLCD1"};
		long timeStart;
	    Random rand = new Random();
		for (int i = 0; i <= NBMEASURE; i++) {
			// Remove PLC1
			Device toRem = m.getDevice(plcNameArray[rand.nextInt(plcNameArray.length)]);
			timeStart = System.currentTimeMillis();
			Model m2 = ReconfigurationConstraintP.reconfigureWithout(toRem, m, false);
			TimeTable[i][0] = System.currentTimeMillis() - timeStart ;
			try {
				cpm.applyNewConf(m2);
			} catch (ModbusException | IOException | InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			TimeTable[i][1] = System.currentTimeMillis() - timeStart ;
			try {
				Thread.sleep(250);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			try {
				cpm.resetAllPLC();
			} catch (ModbusException | IOException | InterruptedException e) {
				e.printStackTrace();
				System.err.println("Issue arose while trying to reinitialize PLCs");
			}
			
		}
		
		File output = new File("ControlDelay_"+ new SimpleDateFormat("yyyyMMdd_HHmmss").format(Calendar.getInstance().getTime()) +".tsv");
		FileWriter outputW;
		try {
			outputW = new FileWriter(output);
		} catch (IOException e) {
			e.printStackTrace();
			return;
		}

		try {
			outputW.append("compTime"+ "\t" + "commTime" + "\n");
		} catch (IOException e) {
			e.printStackTrace();
			return;
		}
		for (int i = 1; i <= NBMEASURE; i++) {
			try {
				outputW.append(TimeTable[i][0] + "\t" + TimeTable[i][1] +"\n");
			} catch (IOException e) {
				e.printStackTrace();
				return;
			}
		}
		System.out.println("Done !");
		try {
			outputW.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		if (true) return;
		
		
		
			boolean cont = true;
			boolean noSave = false;
			while(cont) {
				
				
				ComponentChooser componentChooser = new ComponentChooser();
				componentChooser.showDialog(null, m, true);
	
		        Component selectedComponent = componentChooser.getSelectedComponent();
		        if (selectedComponent != null) {
		            System.out.println("Selected Component: " + selectedComponent.getName());
		            
		            Model m2 = ReconfigurationConstraintP.reconfigureWithout(selectedComponent, m, false);
					if (m2 == null) {
						noSave = true;
						cont = false;
					}
					m = m2;
					
					try {
						cpm.applyNewConf(m2);
					} catch (ModbusException | IOException | InterruptedException e) {
						e.printStackTrace();
						System.err.println("Issue arose while trying to communicate with PLCs");
					}
					
		        } else {
		            System.out.println("User canceled the selection.");
		            cont = false;
		        }
				
			}
			
			if (noSave) {
	            System.out.println("Reconfiguration ended with no application left running, or no solution was chosen");
	            return;
			}
		
	}
}
