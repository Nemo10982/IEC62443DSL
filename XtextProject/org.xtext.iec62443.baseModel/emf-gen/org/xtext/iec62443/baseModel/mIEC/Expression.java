/**
 * generated by Xtext 2.31.0
 */
package org.xtext.iec62443.baseModel.mIEC;

import org.eclipse.emf.ecore.EObject;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Expression</b></em>'.
 * <!-- end-user-doc -->
 *
 *
 * @see org.xtext.iec62443.baseModel.mIEC.MIECPackage#getExpression()
 * @model abstract="true"
 * @generated
 */
public interface Expression extends EObject {
	
	

	
	
	// Check if the expression has the correct type
	static public boolean properlyTyped(Expression scoreExpr, Application a, Device d, int type) {
		if (scoreExpr instanceof TernaryOp) {
			TernaryOp ter = (TernaryOp) scoreExpr;
			return properlyTyped(ter.getOp1(), a, d, Value.BOOLEAN) && determineType(ter.getOp3(), a, d) == determineType(ter.getOp2(), a, d);
		}
		if (scoreExpr instanceof Comparison){

			Comparison comp = (Comparison) scoreExpr;
			return determineType(comp.getOp1(), a, d) == determineType(comp.getOp2(), a, d);
		}
		if (scoreExpr instanceof OperationNumber) {
			OperationNumber opNum = (OperationNumber) scoreExpr;
			return properlyTyped(opNum.getOp1(), a, d, Value.INTEGER) && properlyTyped(opNum.getOp1(), a, d, Value.INTEGER);
		}
		if (scoreExpr instanceof Value) {
			Value val = (Value) scoreExpr;
			int newType = val.getType();
			if (newType == Value.FLOAT) newType = Value.INTEGER;
			return  newType == type;
			
		}
		if (scoreExpr instanceof SelfReference) {
			String name = ((SelfReference) scoreExpr).getReference();
			// If the property is not present, there's an issue
			if (a.getProperty(name) == null) {
				return false;
			}
			// If the property does not have the correct type, same problem
			int newType = a.getProperty(name).getValue().getType();
			if (newType == Value.FLOAT) newType = Value.INTEGER;
			return  newType == type;
		}
		if (scoreExpr instanceof DeviceReference) {
			String name = ((DeviceReference) scoreExpr).getReference();
			// If the property is not present, there's an issue
			if (d.getProperty(name) == null) {
				return false;
			}
			// If the property does not have the correct type, same problem
			int newType = d.getProperty(name).getValue().getType();
			if (newType == Value.FLOAT) newType = Value.INTEGER;
			return  newType == type;
		}
		
		
		return true;
	} 
	
	// get the current type of the expression (int and float are both denoted as int there)
	static public int determineType(Expression scoreExpr, Application a, Device d) {
		if (scoreExpr instanceof TernaryOp) {
			TernaryOp ter = (TernaryOp) scoreExpr;
			return determineType(ter.getOp2(), a, d);
		}
		if (scoreExpr instanceof Comparison){
			return Value.BOOLEAN;
		}
		if (scoreExpr instanceof OperationNumber) {
			return Value.INTEGER;
		}
		if (scoreExpr instanceof Value) {
			Value val = (Value) scoreExpr;
			int newType = val.getType();
			if (newType == Value.FLOAT) newType = Value.INTEGER;
			return  newType;
			
		}
		if (scoreExpr instanceof SelfReference) {
			String name = ((SelfReference) scoreExpr).getReference();
			// If the property is not present, there's an issue
			if (a.getProperty(name) == null) {
				return -1;
			}
			int newType = a.getProperty(name).getValue().getType();
			if (newType == Value.FLOAT) newType = Value.INTEGER;
			return  newType;
		}
		if (scoreExpr instanceof DeviceReference) {
			String name = ((DeviceReference) scoreExpr).getReference();
			// If the property is not present, there's an issue
			if (d.getProperty(name) == null) {
				return -1;
			}
			int newType = d.getProperty(name).getValue().getType();
			if (newType == Value.FLOAT) newType = Value.INTEGER;
			return  newType;
		}
		// Error
		return -1;
	}

	

	public String ExpressiontoString();
	
} // Expression
