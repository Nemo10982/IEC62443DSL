/*
 * generated by Xtext 2.32.0
 */
package org.xtext.iec62443.baseModel.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.iec62443.baseModel.mIEC.Application;
import org.xtext.iec62443.baseModel.mIEC.BooleanValue;
import org.xtext.iec62443.baseModel.mIEC.Channel;
import org.xtext.iec62443.baseModel.mIEC.ClassicalZone;
import org.xtext.iec62443.baseModel.mIEC.Comparison;
import org.xtext.iec62443.baseModel.mIEC.Conduit;
import org.xtext.iec62443.baseModel.mIEC.CounterMeasure;
import org.xtext.iec62443.baseModel.mIEC.DataFlow;
import org.xtext.iec62443.baseModel.mIEC.Device;
import org.xtext.iec62443.baseModel.mIEC.DeviceReference;
import org.xtext.iec62443.baseModel.mIEC.FloatValue;
import org.xtext.iec62443.baseModel.mIEC.IntegerValue;
import org.xtext.iec62443.baseModel.mIEC.MIECPackage;
import org.xtext.iec62443.baseModel.mIEC.Model;
import org.xtext.iec62443.baseModel.mIEC.OperationConstraint;
import org.xtext.iec62443.baseModel.mIEC.OperationNumber;
import org.xtext.iec62443.baseModel.mIEC.OperationNumberNary;
import org.xtext.iec62443.baseModel.mIEC.PresenceConstraint;
import org.xtext.iec62443.baseModel.mIEC.Property;
import org.xtext.iec62443.baseModel.mIEC.SecurityLevels;
import org.xtext.iec62443.baseModel.mIEC.SelfReference;
import org.xtext.iec62443.baseModel.mIEC.StringValue;
import org.xtext.iec62443.baseModel.mIEC.TernaryOp;
import org.xtext.iec62443.baseModel.mIEC.ZoneCharacteristics;
import org.xtext.iec62443.baseModel.services.MiecGrammarAccess;

@SuppressWarnings("all")
public class MiecSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MiecGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MIECPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MIECPackage.APPLICATION:
				sequence_Application(context, (Application) semanticObject); 
				return; 
			case MIECPackage.BOOLEAN_VALUE:
				sequence_BooleanValue(context, (BooleanValue) semanticObject); 
				return; 
			case MIECPackage.CHANNEL:
				sequence_Channel(context, (Channel) semanticObject); 
				return; 
			case MIECPackage.CLASSICAL_ZONE:
				sequence_ClassicalZone(context, (ClassicalZone) semanticObject); 
				return; 
			case MIECPackage.COMPARISON:
				sequence_Comparison(context, (Comparison) semanticObject); 
				return; 
			case MIECPackage.CONDUIT:
				sequence_Conduit(context, (Conduit) semanticObject); 
				return; 
			case MIECPackage.COUNTER_MEASURE:
				sequence_counterMeasure(context, (CounterMeasure) semanticObject); 
				return; 
			case MIECPackage.DATA_FLOW:
				sequence_Dataflow(context, (DataFlow) semanticObject); 
				return; 
			case MIECPackage.DEVICE:
				sequence_Device(context, (Device) semanticObject); 
				return; 
			case MIECPackage.DEVICE_REFERENCE:
				sequence_DeviceReference(context, (DeviceReference) semanticObject); 
				return; 
			case MIECPackage.FLOAT_VALUE:
				sequence_FloatValue(context, (FloatValue) semanticObject); 
				return; 
			case MIECPackage.INTEGER_VALUE:
				if (rule == grammarAccess.getNumberRule()
						|| rule == grammarAccess.getValueOrReferenceRule()
						|| rule == grammarAccess.getValueRule()
						|| rule == grammarAccess.getIntegerValueRule()) {
					sequence_IntegerValue(context, (IntegerValue) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPositiveIntegerValueRule()) {
					sequence_PositiveIntegerValue(context, (IntegerValue) semanticObject); 
					return; 
				}
				else break;
			case MIECPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case MIECPackage.OPERATION_CONSTRAINT:
				sequence_OperationConstraint(context, (OperationConstraint) semanticObject); 
				return; 
			case MIECPackage.OPERATION_NUMBER:
				sequence_NumberOperation(context, (OperationNumber) semanticObject); 
				return; 
			case MIECPackage.OPERATION_NUMBER_NARY:
				if (rule == grammarAccess.getNumberExpressionRule()
						|| rule == grammarAccess.getAdditionRule()
						|| rule == grammarAccess.getNumberRule()
						|| rule == grammarAccess.getExpressionRule()) {
					sequence_Addition(context, (OperationNumberNary) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getDivisionRule()) {
					sequence_Division(context, (OperationNumberNary) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getMultiplicationRule()) {
					sequence_Multiplication(context, (OperationNumberNary) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSoustractionRule()) {
					sequence_Soustraction(context, (OperationNumberNary) semanticObject); 
					return; 
				}
				else break;
			case MIECPackage.PRESENCE_CONSTRAINT:
				sequence_PresenceConstraint(context, (PresenceConstraint) semanticObject); 
				return; 
			case MIECPackage.PROPERTY:
				sequence_Property(context, (Property) semanticObject); 
				return; 
			case MIECPackage.SECURITY_LEVELS:
				sequence_SecurityLevels(context, (SecurityLevels) semanticObject); 
				return; 
			case MIECPackage.SELF_REFERENCE:
				sequence_SelfReference(context, (SelfReference) semanticObject); 
				return; 
			case MIECPackage.STRING_VALUE:
				sequence_StringValue(context, (StringValue) semanticObject); 
				return; 
			case MIECPackage.SYSTEM:
				sequence_System(context, (org.xtext.iec62443.baseModel.mIEC.System) semanticObject); 
				return; 
			case MIECPackage.TERNARY_OP:
				sequence_TernaryOp(context, (TernaryOp) semanticObject); 
				return; 
			case MIECPackage.ZONE_CHARACTERISTICS:
				sequence_FurtherZoneDescription(context, (ZoneCharacteristics) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     NumberExpression returns OperationNumberNary
	 *     Addition returns OperationNumberNary
	 *     Number returns OperationNumberNary
	 *     Expression returns OperationNumberNary
	 *
	 * Constraint:
	 *     (ops+=Soustraction (operation=NumberOperation1 ops+=Soustraction)*)
	 * </pre>
	 */
	protected void sequence_Addition(ISerializationContext context, OperationNumberNary semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Component returns Application
	 *     Application returns Application
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         executedOn=[Device|ID]? 
	 *         capability=SecurityLevels 
	 *         scoreExpr=NumberExpression? 
	 *         (constraints+=Constraint constraints+=Constraint*)? 
	 *         sLevelConstraint=SecurityLevels? 
	 *         (communicatesWith+=[Component|ID] communicatesWith+=[Component|ID]*)? 
	 *         (properties+=Property properties+=Property*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_Application(ISerializationContext context, Application semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns BooleanValue
	 *     BooleanExpression returns BooleanValue
	 *     ValueOrReference returns BooleanValue
	 *     Value returns BooleanValue
	 *     BooleanValue returns BooleanValue
	 *
	 * Constraint:
	 *     value=BOOL
	 * </pre>
	 */
	protected void sequence_BooleanValue(ISerializationContext context, BooleanValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MIECPackage.Literals.BOOLEAN_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MIECPackage.Literals.BOOLEAN_VALUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanValueAccess().getValueBOOLTerminalRuleCall_0(), semanticObject.isValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Channel returns Channel
	 *
	 * Constraint:
	 *     (name=ID connects+=[Component|ID] connects+=[Component|ID] connects+=[Component|ID]*)
	 * </pre>
	 */
	protected void sequence_Channel(ISerializationContext context, Channel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Zone returns ClassicalZone
	 *     ClassicalZone returns ClassicalZone
	 *
	 * Constraint:
	 *     (
	 *         trusted?='trusted'? 
	 *         physical?='physical'? 
	 *         name=ID 
	 *         target=SecurityLevels 
	 *         furtherDesc=FurtherZoneDescription? 
	 *         (components+=Component components+=Component*)? 
	 *         (countermeasures+=counterMeasure countermeasures+=counterMeasure*)? 
	 *         (subZones+=Zone subZones+=Zone*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_ClassicalZone(ISerializationContext context, ClassicalZone semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Comparison
	 *     BooleanExpression returns Comparison
	 *     Comparison returns Comparison
	 *
	 * Constraint:
	 *     (op1=Expression operation=Operation op2=Expression)
	 * </pre>
	 */
	protected void sequence_Comparison(ISerializationContext context, Comparison semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MIECPackage.Literals.COMPARISON__OP1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MIECPackage.Literals.COMPARISON__OP1));
			if (transientValues.isValueTransient(semanticObject, MIECPackage.Literals.COMPARISON__OPERATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MIECPackage.Literals.COMPARISON__OPERATION));
			if (transientValues.isValueTransient(semanticObject, MIECPackage.Literals.COMPARISON__OP2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MIECPackage.Literals.COMPARISON__OP2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonAccess().getOp1ExpressionParserRuleCall_2_0(), semanticObject.getOp1());
		feeder.accept(grammarAccess.getComparisonAccess().getOperationOperationEnumRuleCall_3_0(), semanticObject.getOperation());
		feeder.accept(grammarAccess.getComparisonAccess().getOp2ExpressionParserRuleCall_4_0(), semanticObject.getOp2());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Zone returns Conduit
	 *     Conduit returns Conduit
	 *
	 * Constraint:
	 *     (
	 *         trusted?='trusted'? 
	 *         physical?='physical'? 
	 *         name=ID 
	 *         connects+=[ClassicalZone|ID] 
	 *         connects+=[ClassicalZone|ID]* 
	 *         target=SecurityLevels 
	 *         furtherDesc=FurtherZoneDescription? 
	 *         (components+=Component components+=Component*)? 
	 *         (countermeasures+=counterMeasure countermeasures+=counterMeasure*)? 
	 *         (channels+=Channel channels+=Channel*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_Conduit(ISerializationContext context, Conduit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Dataflow returns DataFlow
	 *
	 * Constraint:
	 *     (source=[Component|ID] destination=[Component|ID] protocol=STRING)
	 * </pre>
	 */
	protected void sequence_Dataflow(ISerializationContext context, DataFlow semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MIECPackage.Literals.DATA_FLOW__SOURCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MIECPackage.Literals.DATA_FLOW__SOURCE));
			if (transientValues.isValueTransient(semanticObject, MIECPackage.Literals.DATA_FLOW__DESTINATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MIECPackage.Literals.DATA_FLOW__DESTINATION));
			if (transientValues.isValueTransient(semanticObject, MIECPackage.Literals.DATA_FLOW__PROTOCOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MIECPackage.Literals.DATA_FLOW__PROTOCOL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDataflowAccess().getSourceComponentIDTerminalRuleCall_1_0_1(), semanticObject.eGet(MIECPackage.Literals.DATA_FLOW__SOURCE, false));
		feeder.accept(grammarAccess.getDataflowAccess().getDestinationComponentIDTerminalRuleCall_3_0_1(), semanticObject.eGet(MIECPackage.Literals.DATA_FLOW__DESTINATION, false));
		feeder.accept(grammarAccess.getDataflowAccess().getProtocolSTRINGTerminalRuleCall_5_0(), semanticObject.getProtocol());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Number returns DeviceReference
	 *     Expression returns DeviceReference
	 *     ValueOrReference returns DeviceReference
	 *     Reference returns DeviceReference
	 *     DeviceReference returns DeviceReference
	 *
	 * Constraint:
	 *     reference=STRING
	 * </pre>
	 */
	protected void sequence_DeviceReference(ISerializationContext context, DeviceReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MIECPackage.Literals.REFERENCE__REFERENCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MIECPackage.Literals.REFERENCE__REFERENCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDeviceReferenceAccess().getReferenceSTRINGTerminalRuleCall_1_0(), semanticObject.getReference());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Component returns Device
	 *     Device returns Device
	 *
	 * Constraint:
	 *     (
	 *         network?='network'? 
	 *         embedded?='embedded'? 
	 *         host?='host'? 
	 *         name=ID 
	 *         capability=SecurityLevels 
	 *         (properties+=Property properties+=Property*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_Device(ISerializationContext context, Device semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Division returns OperationNumberNary
	 *
	 * Constraint:
	 *     (ops+=Number (operation=NumberOperation4 ops+=Number)*)
	 * </pre>
	 */
	protected void sequence_Division(ISerializationContext context, OperationNumberNary semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Number returns FloatValue
	 *     ValueOrReference returns FloatValue
	 *     Value returns FloatValue
	 *     FloatValue returns FloatValue
	 *
	 * Constraint:
	 *     value=FLOAT
	 * </pre>
	 */
	protected void sequence_FloatValue(ISerializationContext context, FloatValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MIECPackage.Literals.FLOAT_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MIECPackage.Literals.FLOAT_VALUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFloatValueAccess().getValueFLOATTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FurtherZoneDescription returns ZoneCharacteristics
	 *
	 * Constraint:
	 *     (
	 *         logicalBoundary=STRING 
	 *         physicalBoundary=STRING 
	 *         (organizations+=STRING organizations+=STRING*)? 
	 *         (physicalAccessPoints+=STRING physicalAccessPoints+=STRING*)? 
	 *         (securityPolicies+=STRING securityPolicies+=STRING*)? 
	 *         (dataflows+=Dataflow dataflows+=Dataflow*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_FurtherZoneDescription(ISerializationContext context, ZoneCharacteristics semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Number returns IntegerValue
	 *     ValueOrReference returns IntegerValue
	 *     Value returns IntegerValue
	 *     IntegerValue returns IntegerValue
	 *
	 * Constraint:
	 *     value=SINT
	 * </pre>
	 */
	protected void sequence_IntegerValue(ISerializationContext context, IntegerValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MIECPackage.Literals.INTEGER_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MIECPackage.Literals.INTEGER_VALUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntegerValueAccess().getValueSINTTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     ((name=ID function=STRING equipmentDescription=STRING assumptionsOnLocation=STRING)? (zones+=ClassicalZone | conduits+=Conduit)*)
	 * </pre>
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Multiplication returns OperationNumberNary
	 *
	 * Constraint:
	 *     (ops+=Division (operation=NumberOperation3 ops+=Division)*)
	 * </pre>
	 */
	protected void sequence_Multiplication(ISerializationContext context, OperationNumberNary semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NumberOperation returns OperationNumber
	 *     Number returns OperationNumber
	 *
	 * Constraint:
	 *     (operation=NumberOperationStart op1=NumberExpression op2=NumberExpression)
	 * </pre>
	 */
	protected void sequence_NumberOperation(ISerializationContext context, OperationNumber semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MIECPackage.Literals.OPERATION_NUMBER__OPERATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MIECPackage.Literals.OPERATION_NUMBER__OPERATION));
			if (transientValues.isValueTransient(semanticObject, MIECPackage.Literals.OPERATION_NUMBER__OP1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MIECPackage.Literals.OPERATION_NUMBER__OP1));
			if (transientValues.isValueTransient(semanticObject, MIECPackage.Literals.OPERATION_NUMBER__OP2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MIECPackage.Literals.OPERATION_NUMBER__OP2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNumberOperationAccess().getOperationNumberOperationStartEnumRuleCall_0_0(), semanticObject.getOperation());
		feeder.accept(grammarAccess.getNumberOperationAccess().getOp1NumberExpressionParserRuleCall_2_0(), semanticObject.getOp1());
		feeder.accept(grammarAccess.getNumberOperationAccess().getOp2NumberExpressionParserRuleCall_4_0(), semanticObject.getOp2());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Constraint returns OperationConstraint
	 *     OperationConstraint returns OperationConstraint
	 *
	 * Constraint:
	 *     (optional?='optional'? propertyName=ID operation=Operation value=ValueOrReference)
	 * </pre>
	 */
	protected void sequence_OperationConstraint(ISerializationContext context, OperationConstraint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PositiveIntegerValue returns IntegerValue
	 *
	 * Constraint:
	 *     value=SINT
	 * </pre>
	 */
	protected void sequence_PositiveIntegerValue(ISerializationContext context, IntegerValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MIECPackage.Literals.INTEGER_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MIECPackage.Literals.INTEGER_VALUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPositiveIntegerValueAccess().getValueSINTTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Constraint returns PresenceConstraint
	 *     PresenceConstraint returns PresenceConstraint
	 *
	 * Constraint:
	 *     (optional?='optional'? propertyName=ID)
	 * </pre>
	 */
	protected void sequence_PresenceConstraint(ISerializationContext context, PresenceConstraint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Property returns Property
	 *
	 * Constraint:
	 *     (name=ID value=Value)
	 * </pre>
	 */
	protected void sequence_Property(ISerializationContext context, Property semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MIECPackage.Literals.PROPERTY__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MIECPackage.Literals.PROPERTY__NAME));
			if (transientValues.isValueTransient(semanticObject, MIECPackage.Literals.PROPERTY__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MIECPackage.Literals.PROPERTY__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPropertyAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPropertyAccess().getValueValueParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SecurityLevels returns SecurityLevels
	 *
	 * Constraint:
	 *     (
	 *         accessControl=SecurityLevel 
	 *         useControl=SecurityLevel 
	 *         systemIntegrity=SecurityLevel 
	 *         dataConfidentiality=SecurityLevel 
	 *         restrictedDataFlow=SecurityLevel 
	 *         timelyResponse=SecurityLevel 
	 *         resourceAvailability=SecurityLevel
	 *     )
	 * </pre>
	 */
	protected void sequence_SecurityLevels(ISerializationContext context, SecurityLevels semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MIECPackage.Literals.SECURITY_LEVELS__ACCESS_CONTROL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MIECPackage.Literals.SECURITY_LEVELS__ACCESS_CONTROL));
			if (transientValues.isValueTransient(semanticObject, MIECPackage.Literals.SECURITY_LEVELS__USE_CONTROL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MIECPackage.Literals.SECURITY_LEVELS__USE_CONTROL));
			if (transientValues.isValueTransient(semanticObject, MIECPackage.Literals.SECURITY_LEVELS__SYSTEM_INTEGRITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MIECPackage.Literals.SECURITY_LEVELS__SYSTEM_INTEGRITY));
			if (transientValues.isValueTransient(semanticObject, MIECPackage.Literals.SECURITY_LEVELS__DATA_CONFIDENTIALITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MIECPackage.Literals.SECURITY_LEVELS__DATA_CONFIDENTIALITY));
			if (transientValues.isValueTransient(semanticObject, MIECPackage.Literals.SECURITY_LEVELS__RESTRICTED_DATA_FLOW) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MIECPackage.Literals.SECURITY_LEVELS__RESTRICTED_DATA_FLOW));
			if (transientValues.isValueTransient(semanticObject, MIECPackage.Literals.SECURITY_LEVELS__TIMELY_RESPONSE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MIECPackage.Literals.SECURITY_LEVELS__TIMELY_RESPONSE));
			if (transientValues.isValueTransient(semanticObject, MIECPackage.Literals.SECURITY_LEVELS__RESOURCE_AVAILABILITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MIECPackage.Literals.SECURITY_LEVELS__RESOURCE_AVAILABILITY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSecurityLevelsAccess().getAccessControlSecurityLevelEnumRuleCall_1_0(), semanticObject.getAccessControl());
		feeder.accept(grammarAccess.getSecurityLevelsAccess().getUseControlSecurityLevelEnumRuleCall_3_0(), semanticObject.getUseControl());
		feeder.accept(grammarAccess.getSecurityLevelsAccess().getSystemIntegritySecurityLevelEnumRuleCall_5_0(), semanticObject.getSystemIntegrity());
		feeder.accept(grammarAccess.getSecurityLevelsAccess().getDataConfidentialitySecurityLevelEnumRuleCall_7_0(), semanticObject.getDataConfidentiality());
		feeder.accept(grammarAccess.getSecurityLevelsAccess().getRestrictedDataFlowSecurityLevelEnumRuleCall_9_0(), semanticObject.getRestrictedDataFlow());
		feeder.accept(grammarAccess.getSecurityLevelsAccess().getTimelyResponseSecurityLevelEnumRuleCall_11_0(), semanticObject.getTimelyResponse());
		feeder.accept(grammarAccess.getSecurityLevelsAccess().getResourceAvailabilitySecurityLevelEnumRuleCall_13_0(), semanticObject.getResourceAvailability());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Number returns SelfReference
	 *     Expression returns SelfReference
	 *     ValueOrReference returns SelfReference
	 *     Reference returns SelfReference
	 *     SelfReference returns SelfReference
	 *
	 * Constraint:
	 *     reference=STRING
	 * </pre>
	 */
	protected void sequence_SelfReference(ISerializationContext context, SelfReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MIECPackage.Literals.REFERENCE__REFERENCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MIECPackage.Literals.REFERENCE__REFERENCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSelfReferenceAccess().getReferenceSTRINGTerminalRuleCall_1_0(), semanticObject.getReference());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Soustraction returns OperationNumberNary
	 *
	 * Constraint:
	 *     (ops+=Multiplication (operation=NumberOperation2 ops+=Multiplication)*)
	 * </pre>
	 */
	protected void sequence_Soustraction(ISerializationContext context, OperationNumberNary semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns StringValue
	 *     StringExpression returns StringValue
	 *     ValueOrReference returns StringValue
	 *     Value returns StringValue
	 *     StringValue returns StringValue
	 *
	 * Constraint:
	 *     value=STRING
	 * </pre>
	 */
	protected void sequence_StringValue(ISerializationContext context, StringValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MIECPackage.Literals.STRING_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MIECPackage.Literals.STRING_VALUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringValueAccess().getValueSTRINGTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Component returns System
	 *     System returns System
	 *
	 * Constraint:
	 *     (name=ID capability=SecurityLevels (devices+=Device devices+=Device*)? (properties+=Property properties+=Property*)?)
	 * </pre>
	 */
	protected void sequence_System(ISerializationContext context, org.xtext.iec62443.baseModel.mIEC.System semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TernaryOp returns TernaryOp
	 *     Number returns TernaryOp
	 *
	 * Constraint:
	 *     (op1=Expression op2=Expression op3=Expression)
	 * </pre>
	 */
	protected void sequence_TernaryOp(ISerializationContext context, TernaryOp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MIECPackage.Literals.TERNARY_OP__OP1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MIECPackage.Literals.TERNARY_OP__OP1));
			if (transientValues.isValueTransient(semanticObject, MIECPackage.Literals.TERNARY_OP__OP2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MIECPackage.Literals.TERNARY_OP__OP2));
			if (transientValues.isValueTransient(semanticObject, MIECPackage.Literals.TERNARY_OP__OP3) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MIECPackage.Literals.TERNARY_OP__OP3));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTernaryOpAccess().getOp1ExpressionParserRuleCall_2_0(), semanticObject.getOp1());
		feeder.accept(grammarAccess.getTernaryOpAccess().getOp2ExpressionParserRuleCall_4_0(), semanticObject.getOp2());
		feeder.accept(grammarAccess.getTernaryOpAccess().getOp3ExpressionParserRuleCall_6_0(), semanticObject.getOp3());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     counterMeasure returns CounterMeasure
	 *
	 * Constraint:
	 *     (inactive?='inactive'? name=ID capability=SecurityLevels cost=PositiveIntegerValue?)
	 * </pre>
	 */
	protected void sequence_counterMeasure(ISerializationContext context, CounterMeasure semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
